/* Fixed height skiplist: A skiplist implementation with an array of "next"
 * nodes of fixed height.
 */

import "stdio.h";

typedef node =
    { key      i64,            // Value.
      toplevel i32,            // Height.
      inserted bool,
      next     [20]*node       // Follow-list of nodes.
    };

export opaque
typedef linden_jonsson_queue_t =
    {
        boundoffset u64,
        head  node,
        tail  node
    };

/** Print out the contents of the skip list along with node heights.
 */
export
def linden_jonsson_pqueue_print (set *linden_jonsson_queue_t) -> void
begin
    var raw_node = set.head.next[0];
    while unmark(raw_node) != &set.tail do
        var node = unmark(raw_node);
        printf("node[%d]: %lld deleted: %d\n", node.toplevel, node.key,
            is_marked(raw_node));
        raw_node = node.next[0];
    od
end

/** Return a new fixed-height skip list.
 */
export
def linden_jonsson_pqueue_create (boundoffset u64) -> *linden_jonsson_queue_t
begin
    var linden_jonsson_queue = new linden_jonsson_queue_t;
    linden_jonsson_queue.boundoffset = boundoffset;
    linden_jonsson_queue.head.key = 0x8000000000000000I64;
    linden_jonsson_queue.tail.key = 0x7FFFFFFFFFFFFFFFI64;
    for var i = 0; i < 20; ++i do
        linden_jonsson_queue.head.next[i] = &linden_jonsson_queue.tail;
        linden_jonsson_queue.tail.next[i] = nil;
    od
    return linden_jonsson_queue;
end

def node_create(key i64, toplevel i32) -> *node
begin
    var node = new node;
    node.key = key;
    node.toplevel = toplevel;
    node.inserted = false;
    return node;
end

def locate_preds(set *linden_jonsson_queue_t,
    x u64,
    preds [20]*node,
    succs [20]*node
    ) -> *node
begin
    var cur *node= &set.head;
    var next *node = nil;
    var del *node = nil;
    var level i64 = 19;
    var deleted = false;
    while level >= 0 do
        next = cur.next[level];
        deleted = is_marked(next);
        next = unmark(next);

        while (next.key < x ||
            is_marked(next.next[0]) ||
            (level == 0 && deleted)) do
            if level == 0 && deleted then
                del = next;
            fi
            cur = next;
            next = next.next[level];
            deleted = is_marked(next);
            next = unmark(next);
        od
        preds[level] = cur;
        succs[level] = next;
        level--;
    od
    return del;
end

/** Add a node, lock-free, to the skiplist.
 */
export
def linden_jonsson_pqueue_add (seed *u64, set *linden_jonsson_queue_t, x i64) -> bool
begin
    var preds [20]*node;
    var succs [20]*node;
    var toplevel = random_level(seed, 20);
    var node *node = nil;
    while true do
        var del = locate_preds(set, x, preds, succs);
        if succs[0].key == x &&
            !is_marked(preds[0].next[0]) &&
            preds[0].next[0] == succs[0] then
            if node != nil then
                delete node;
            fi
            return false;
        fi

        if node == nil then
            node = node_create(x, toplevel);
        fi

        for var i = 0; i <= toplevel; ++i do
            node.next[i] = succs[i];
        od
        var pred = preds[0];
        var succ = succs[0];
        if !__builtin_cas(&pred.next[0], succ, node) then
            continue;
        fi
        for var i = 1; i <= toplevel; ++i do
            if (is_marked(node.next[0]) ||
                is_marked(succs[i].next[0]) ||
                del == succs[i]) then
                node.inserted = true;
                return true;
            fi

            node.next[i] = succs[i];

            if !__builtin_cas(&pred.next[i], succs[i], node) then
                del = locate_preds(set, x, preds, succs);
                if(succs[0] != node) then
                    node.inserted = true;
                    return true;
                fi
            fi
        od
        node.inserted = true;
        return true;
    od
end


def restructure(set *linden_jonsson_queue_t) -> void
begin
    var pred *node = &set.head;
    var cur *node = nil;
    var head *node = nil;
    var level = 19;
    while level > 0 do
        head = set.head.next[level];
        cur = pred.next[level];
        if !is_marked(head.next[0]) then
            level--;
            continue;
        fi
        while is_marked(cur.next[0]) do
            pred = cur;
            cur = pred.next[level];
        od
        if __builtin_cas(&set.head.next[level], head, cur) then
            level--;
        fi
    od
end

/** Pop the front node from the list.  Return true iff there was a node to pop.
 *  Leak the memory.
 */
export
def linden_jonsson_pqueue_leaky_pop_min (set *linden_jonsson_queue_t) -> bool
begin

    var cur *node = &set.head;
    var next *node = nil;
    var newhead *node = nil;
    var obs_head *node = cur.next[0];
    var offset i32 = 0;
    
    while true do
        offset++;
        next = cur.next[0];
        if(unmark(next) == &set.tail) then return false; fi
        if newhead == nil && !cur.inserted then newhead = cur; fi
        if is_marked(next) then cur = unmark(next); continue; fi
        var res = __builtin_cas(&cur.next[0], unmark(next), mark(next));
        if res then
            cur = unmark(next);
            break;
        fi
        cur = unmark(next);
    od

    if newhead == nil then newhead = cur; fi
    if offset <= set.boundoffset then return true; fi
    if set.head.next[0] != obs_head then return true; fi

    if __builtin_cas(&set.head.next[0], obs_head, mark(newhead)) then
        restructure(set);
        //linden_jonsson_pqueue_print(set);
/*        cur = unmark(obs_head);
        while cur != unmark(obs_head) do
            next = unmark(cur.next[0]);
            cur = next;
        od*/
    fi
    return true;
end


def fast_rand (seed *u64) -> u64
begin
    var val = seed[0];
    if val == 0 then val = 1; fi

    val ^= val << 6;
    val ^= val >> 21;
    val ^= val << 7;

    seed[0] = val;
    return val;
end

def random_level (seed *u64, max u32) -> u32
begin
    var level = 1;
    while fast_rand(seed) % 2 == 0 && level < max do
        ++level;
    od
    return level - 1;
end

def ref_and_markbit (ptr *node) -> { *node, bool } =
    { unmark(ptr), is_marked(ptr) };

def mark (ptr *node) -> *node =
    cast(type *node, 0x1I64 | cast(type i64, ptr));

def unmark (ptr *node) -> *node =
    cast(type *node, 0xFFFFFFFFFFFFFFFEI64 & cast(type i64, ptr));

def is_marked (ptr *node) -> bool =
    cast(type bool, 0x1I64 & cast(type i64, ptr));
