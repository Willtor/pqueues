/* Fixed height skiplist: A skiplist implementation with an array of "next"
 * nodes of fixed height.
 */

import "stdio.h";
import "math.h";

typedef node_ptr = volatile*volatile node_t;

typedef node_state_t = enum
    | PADDING
    | ACTIVE
    | DELETED
    ;

typedef node_t =
    {
      priority i64,                 // Key.
      toplevel i32,                 // Height.
      state volatile node_state_t,
      next     [20]node_ptr          // Follow-list of nodes.
    };

export opaque
typedef spray_pq_config_t =
    {
      thread_count i64,
      start_height i64,
      max_jump i64,
      descend_amount i64,
      padding_amount i64
    };

// Strange BUG I found trying to initialise this struct
export
def spray_pq_config_paper(threads u64) -> spray_pq_config_t
begin
  var log_arg = threads;
  if threads == 1 then
    log_arg = 2;
  fi

  var spray_config spray_pq_config_t = {
    cast(type i64, threads), cast(type i64, log2(threads) + 1),
    cast(type i64, log2(threads) + 1), 1I64, 
    (threads * cast(type i64, log2(log_arg))) / 2
  };
  return spray_config;
end

export opaque
typedef spray_pq_t =
    {
      config spray_pq_config_t,
      padding_head  *node_t,
      head  node_t,
      tail  node_t
    };


def print_node(node node_ptr) -> void
begin
    printf("node[%d]: %lld ", node.toplevel, node.priority);
    if node.state == DELETED then
        printf("DELETED\n");
    elif node.state == PADDING then
        printf("PADDING\n");
    else
        printf("ACTIVE\n");
    fi
end

/** Print out the contents of the skip list along with node heights.
 */
export
def spray_pq_print (pqueue *spray_pq_t) -> void
begin
    printf("HEAD: %lld ", pqueue.head.priority);
    print_node(&pqueue.head);
    var node = pqueue.head.next[0];
    while unmark(node) != &pqueue.tail do
        if !is_marked(node.next[0]) then
            node = unmark(node);
            print_node(node);
        fi
        node = unmark(node).next[0];
    od
    print_node(&pqueue.tail);
end

def node_create(priority i64, toplevel i32, state node_state_t) -> node_ptr
begin
    var node = new node_t;
    node.priority = priority;
    node.toplevel = toplevel;
    node.state = state;
    return node;
end

/** Return a new fixed-height skip list.
 */
export
def spray_pq_create (threads u64) -> *spray_pq_t
begin
    var config = spray_pq_config_paper(threads);
    var spray_pqueue = new spray_pq_t;
    spray_pqueue.config = config;
    spray_pqueue.head.priority = 0x8000000000000000I64;
    spray_pqueue.head.state = PADDING;
    spray_pqueue.tail.priority = 0x7FFFFFFFFFFFFFFFI64;
    spray_pqueue.tail.state = PADDING;
    for var i = 0; i < 20; ++i do
        spray_pqueue.head.next[i] = &spray_pqueue.tail;
        spray_pqueue.tail.next[i] = nil;
    od
    // Insert dummy nodes
    spray_pqueue.padding_head = &spray_pqueue.head;
    for var i = 1; i < config.padding_amount; ++i do
        var padding_node = node_create(0x8000000000000000I64, 19, PADDING);
        // Dummy nodes are fully connected.
        for var j = 0; j < 20; ++j do
            padding_node.next[j] = spray_pqueue.padding_head;
        od
        spray_pqueue.padding_head = padding_node;
    od
    return spray_pqueue;
end

/** Add a node, lock-free, to the priority queue.
 */
export
def spray_pq_add (seed *u64, pqueue *spray_pq_t, priority i64) -> bool
begin
    var preds [20]node_ptr;
    var succs [20]node_ptr;
    var toplevel = random_level(seed, 20);
    var node node_ptr = nil;
    while true do
        if find(pqueue, priority, preds, succs) then
            delete node;
            return false;
        else
            if node == nil then node = node_create(priority, toplevel, ACTIVE); fi
            for var i = 0; i <= toplevel; ++i do
                node.next[i] = succs[i];
            od
            var pred = preds[0];
            var succ = succs[0];
            if !__builtin_cas(&pred.next[0], succ, node) then
                continue;
            fi
            for var i = 1; i <= toplevel; ++i do
                while true do
                    pred = preds[i];
                    succ = succs[i];
                    if __builtin_cas(&pred.next[i], succ, node) then
                        break;
                    fi
                    find(pqueue, priority, preds, succs);
                od
            od
            return true;
        fi
    od
end

/** Remove a node, lock-free, from the skiplist.
 */
def spray_pq_remove (pqueue *spray_pq_t, x i64) -> bool
begin
    var preds [20]node_ptr;
    var succs [20]node_ptr;
    var succ node_ptr;
    while true do
        if false == find(pqueue, x, preds, succs) then
            return false;
        else
            var node_to_remove = succs[0];
            var marked bool;
            for var level = node_to_remove.toplevel;
                level >= 1;
                --level
            do
                succ = node_to_remove.next[level];
                marked = is_marked(succ);
                while !marked do
                    __builtin_cas(&node_to_remove.next[level], unmark(succ),
                                  mark(succ));
                    succ = node_to_remove.next[level];
                    marked = is_marked(succ);
                od
            od
            succ = node_to_remove.next[0];
            marked = is_marked(succ);
            while true do
                var i_marked_it = __builtin_cas(&node_to_remove.next[0],
                                                unmark(succ), mark(succ));
                succ = succs[0].next[0];
                marked = is_marked(succ);
                if i_marked_it then
                    // FIXME: succs[0]?  Should retire node_to_remove?
                    retire succs[0];
                    find(pqueue, x, preds, succs);
                    return true;
                elif marked then
                    return false;
                fi
            od
        fi
    od
end

/** Remove a node, lock-free, from the skiplist.  Leak the memory.
 */
def spray_pq_leaky_remove (pqueue *spray_pq_t, x i64) -> bool
begin
    var preds [20]node_ptr;
    var succs [20]node_ptr;
    var succ node_ptr;
    while true do
        if false == find(pqueue, x, preds, succs) then
            return false;
        else
            var node_to_remove = succs[0];
            var marked bool;
            for var level = node_to_remove.toplevel;
                level >= 1;
                --level
            do
                succ = node_to_remove.next[level];
                marked = is_marked(succ);
                while !marked do
                    __builtin_cas(&node_to_remove.next[level], unmark(succ),
                                  mark(succ));
                    succ = node_to_remove.next[level];
                    marked = is_marked(succ);
                od
            od
            succ = node_to_remove.next[0];
            marked = is_marked(succ);
            while true do
                var i_marked_it = __builtin_cas(&node_to_remove.next[0],
                                                unmark(succ), mark(succ));
                succ = succs[0].next[0];
                marked = is_marked(succ);
                if i_marked_it then
                    find(pqueue, x, preds, succs);
                    return true;
                elif marked then
                    return false;
                fi
            od
        fi
    od
end

/** Remove a node, lock-free, from the skiplist.
 */
export
def spray_pq_pop_min (seed *u64, pqueue *spray_pq_t) -> bool
begin
  
  for var node = spray(seed, pqueue); node != &pqueue.tail; node = unmark(node.next[0]) do
    
    // Spray failed, try again
    if node.state == PADDING || node.state == DELETED then
      continue;
    fi

    var res = __builtin_cas(&node.state, ACTIVE, DELETED);
    // We didn't delete a node from the list.
    if res then
      var removed = spray_pq_leaky_remove(pqueue, node.priority);
      if removed then retire node; fi
      return true;
    fi
  od
  return false;
end

/** Remove a node, lock-free, from the skiplist.  Leak the memory.
 */
export
def spray_pq_leaky_pop_min (seed *u64, pqueue *spray_pq_t) -> bool
begin  
  for var node = spray(seed, pqueue); node != &pqueue.tail; node = unmark(node.next[0]) do
    
    // Spray failed, try again
    if node.state == PADDING || node.state == DELETED then
      continue;
    fi

    var res = __builtin_cas(&node.state, ACTIVE, DELETED);
    // We didn't delete a node from the list.
    if res then
      return spray_pq_leaky_remove(pqueue, node.priority);
    fi
  od
  return false;
end

def fast_rand (seed *u64) -> u64
begin
    var val = seed[0];
    if val == 0 then val = 1; fi

    val ^= val << 6;
    val ^= val >> 21;
    val ^= val << 7;

    seed[0] = val;
    return val;
end

def random_level (seed *u64, max u32) -> u32
begin
    var level = 1;
    while fast_rand(seed) % 2 == 0 && level < max do
        ++level;
    od
    return level - 1;
end

def spray (seed *u64, pqueue *spray_pq_t) -> node_ptr
begin
  var tail = &pqueue.tail;
  var cur_node node_ptr = unmark(pqueue.padding_head);
  var D = pqueue.config.descend_amount;
  for var H = pqueue.config.start_height; H >= 0; H = H - D do
    var jump i64 = fast_rand(seed) % (pqueue.config.max_jump + 1);
    while jump > 0 do
      var next = unmark(cur_node.next[H]);
      if next == nil || next == tail then
        break;
      fi
      cur_node = next;
      jump--;
    od
  od
  return cur_node;
end 

def find (pqueue *spray_pq_t, priority i64, preds [20]node_ptr, succs [20]node_ptr) -> bool
begin
    var marked, snip bool;
    var pred, curr, succ node_ptr = nil, nil, nil;
retry:
    while true do
        pred = &pqueue.head;
        for var level = 19; level >= 0; --level do
            curr = unmark(pred.next[level]);
            while true do
                { succ, marked } = ref_and_markbit(curr.next[level]);
                while marked do
                    snip = __builtin_cas(&pred.next[level], curr, succ);
                    if !snip then goto retry; fi
                    curr = unmark(pred.next[level]);
                    { succ, marked } = ref_and_markbit(curr.next[level]);
                od
                if curr.priority < priority then
                    pred = curr;
                    curr = succ;  
                else
                    break;
                fi
            od
            preds[level] = pred;
            succs[level] = curr;
        od
        return curr.priority == priority;
    od
end

def ref_and_markbit (ptr node_ptr) -> { node_ptr, bool } =
    { unmark(ptr), is_marked(ptr) };

def mark (ptr node_ptr) -> node_ptr =
    cast(type node_ptr, 0x1I64 | cast(type i64, ptr));

def unmark (ptr node_ptr) -> node_ptr =
    cast(type node_ptr, 0xFFFFFFFFFFFFFFFEI64 & cast(type i64, ptr));

def is_marked (ptr node_ptr) -> bool =
    cast(type bool, 0x1I64 & cast(type i64, ptr));
